#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include "cuda.h"
#include <string.h>

#define MIN_SIZE 64
#define MAX_SIZE 4096
#define DEBUG 1
#define TEST_DATA 0
#define TEST_ELEMENT 3
#define RESULT_COLUMN 0
#define MIN(x,y)((x)<(y)? x:y )
#define MAX(x,y)((x)>(y)? x:y )
#define MAXBLOCKSIZE 64

int Size;
float *a, *b, *finalVec;
float *m;
unsigned int g_uiColumns;
unsigned int g_uiRows;
unsigned int g_iSizeParameter;
float *g_fGuassionElementsCPU;
float *g_fGuassionElementsGPU;


void testData(  float **pr_vMatrix ){
        (*pr_vMatrix)[0] = 10;
        (*pr_vMatrix)[1] = -7;
        (*pr_vMatrix)[2] = 3;
        (*pr_vMatrix)[3] = -6;
        (*pr_vMatrix)[4] = 8;
        (*pr_vMatrix)[5] = 4;
        (*pr_vMatrix)[6] = 2;
        (*pr_vMatrix)[7] = 6;
        (*pr_vMatrix)[8] = 9;
}
// checking the answwer of the Test data
void checkAnswer(const float  *prStrSharedData ){

        FILE *l_ptrFileOutput ;
        l_ptrFileOutput = fopen("result.txt","r+");
        if( l_ptrFileOutput == NULL ){
                printf("\n Error : In opening file ");
        }else{
                float* result_vector = (float*) malloc(sizeof(float)*TEST_ELEMENT);
                float row_sum;

                for (int j=0; j<TEST_ELEMENT; j++){
                        row_sum = 0;
                        for (int k=0; k<=TEST_ELEMENT; k++){
                                row_sum += prStrSharedData[j*TEST_ELEMENT+k];
                        }
                        result_vector[j] = row_sum;
                        printf(" \n result_vector[ %f ]",result_vector[j]);
                }

                float sumOfSquares = 0;
                float entryOfResidual;
                float element = 0 ;
                for (int i=0; i<TEST_ELEMENT; i++){
                        int scn = fscanf(l_ptrFileOutput,"%f", &element) ;
                        entryOfResidual = result_vector[i] - element;
                        sumOfSquares += entryOfResidual*entryOfResidual;
                }
                float squares = 0 ;
                int scn = fscanf(l_ptrFileOutput,"%f", &squares) ;
                sumOfSquares = sqrt(sumOfSquares);
                printf("squares === %.20f \n", squares);

                if( squares == sumOfSquares)
			printf("\n SUCESSS :: The L2-Norm of the result vector from Ax-b is: %.20f\n", sumOfSquares);
                else
                 printf("\n FAIL :: The Bench Mark for L2-Norm  %.20f & result is %.20f \n", squares, sumOfSquares);

                free(result_vector);
                fclose(l_ptrFileOutput);
        }
}


/*------------------------------------------------------
 ** PrintMat() -- Print the contents of the matrix
 **------------------------------------------------------
 */
void PrintMat(float *ary, int nrow, int ncol)
{
	int i, j;
	
	for (i=0; i<nrow; i++) {
		for (j=0; j<ncol; j++) {
			printf("%8.2f ", *(ary+Size*i+j));
		}
		printf("\n");
	}
	printf("\n");
}

/*------------------------------------------------------
 ** InitAry() -- Initialize the array (vector) by reading
 ** data from the data file
 **------------------------------------------------------
 */
void InitAry(float *ary, int ary_size)
{
	int i;
	
	for (i=0; i<ary_size; i++) {
		ary[i] = ( (float)rand()/(float) (RAND_MAX/10)  );
	}
}  

/*------------------------------------------------------
 ** PrintAry() -- Print the contents of the array (vector)
 **------------------------------------------------------
 */
void PrintAry(float *ary, int ary_size)
{
	int i;
	for (i=0; i<ary_size; i++) {
		printf("%.2f ", ary[i]);
	}
	printf("\n\n");
}
 
//////////////////////// INITALIZE THE REQUIRED MATRIX //////////////////////////////////////////
void initializeMatrixFunc(int pr_iSizeParameter , float **pr_fMultiDimArray ){
        int l_iOuterBound   ;
        for ( l_iOuterBound = 0 ; l_iOuterBound < pr_iSizeParameter ; l_iOuterBound++ ){
                (*pr_fMultiDimArray)[l_iOuterBound] = ( (float)rand()/(float) (RAND_MAX/10)  );
        }//outerBound ends
}//intializeMatrix ends
 


/*-------------------------------------------------------
 ** Fan1() -- Calculate multiplier matrix
 ** Pay attention to the index.  Index i give the range
 ** which starts from 0 to range-1.  The real values of
 ** the index should be adjust and related with the value
 ** of t which is defined on the ForwardSub().
 **-------------------------------------------------------
 */
__global__ void Fan1(float *m_cuda, float *a_cuda, int Size, int t)
{   
	//if(threadIdx.x + blockIdx.x * blockDim.x >= Size-1-t) printf(".");
	//printf("blockIDx.x:%d,threadIdx.x:%d,Size:%d,t:%d,Size-1-t:%d\n",blockIdx.x,threadIdx.x,Size,t,Size-1-t);

	if(threadIdx.x + blockIdx.x * blockDim.x >= Size-1-t) return;
	*(m_cuda+Size*(blockDim.x*blockIdx.x+threadIdx.x+t+1)+t) = *(a_cuda+Size*(blockDim.x*blockIdx.x+threadIdx.x+t+1)+t) / *(a_cuda+Size*t+t);
}

/*-------------------------------------------------------
 ** Fan2() -- Modify the matrix A into LUD
 **-------------------------------------------------------
 */ 

__global__ void Fan2(float *m_cuda, float *a_cuda, float *b_cuda,int Size, int j1, int t)
{
	if(threadIdx.x + blockIdx.x * blockDim.x >= Size-1-t) return;
	if(threadIdx.y + blockIdx.y * blockDim.y >= Size-t) return;
	
	int xidx = blockIdx.x * blockDim.x + threadIdx.x;
	int yidx = blockIdx.y * blockDim.y + threadIdx.y;
	//printf("blockIdx.x:%d,threadIdx.x:%d,blockIdx.y:%d,threadIdx.y:%d,blockDim.x:%d,blockDim.y:%d\n",blockIdx.x,threadIdx.x,blockIdx.y,threadIdx.y,blockDim.x,blockDim.y);
	
	a_cuda[Size*(xidx+1+t)+(yidx+t)] -= m_cuda[Size*(xidx+1+t)+t] * a_cuda[Size*t+(yidx+t)];
	//a_cuda[xidx+1+t][yidx+t] -= m_cuda[xidx+1+t][t] * a_cuda[t][yidx+t];
	if(yidx == 0){
		//printf("blockIdx.x:%d,threadIdx.x:%d,blockIdx.y:%d,threadIdx.y:%d,blockDim.x:%d,blockDim.y:%d\n",blockIdx.x,threadIdx.x,blockIdx.y,threadIdx.y,blockDim.x,blockDim.y);
		//printf("xidx:%d,yidx:%d\n",xidx,yidx);
		b_cuda[xidx+1+t] -= m_cuda[Size*(xidx+1+t)+(yidx+t)] * b_cuda[t];
	}
}

/*------------------------------------------------------
 ** ForwardSub() -- Forward substitution of Gaussian
 ** elimination.
 **------------------------------------------------------
 */
void performForwardSub()
{
	int t;
    float *m_cuda,*a_cuda,*b_cuda;
	
	// allocate memory on GPU
	cudaMalloc((void **) &m_cuda, Size * Size * sizeof(float));
	 
	cudaMalloc((void **) &a_cuda, Size * Size * sizeof(float));
	
	cudaMalloc((void **) &b_cuda, Size * sizeof(float));	

	// copy memory to GPU
	cudaMemcpy(a_cuda, a, Size * Size * sizeof(float),cudaMemcpyHostToDevice );
	cudaMemcpy(b_cuda, b, Size * sizeof(float),cudaMemcpyHostToDevice );
	
	int block_size,grid_size;
	
	block_size = MAXBLOCKSIZE;
	grid_size = (Size/block_size) + (!(Size%block_size)? 0:1);
	//printf("1d grid size: %d\n",grid_size);


	dim3 dimBlock(block_size);
	dim3 dimGrid(grid_size);
	//dim3 dimGrid( (N/dimBlock.x) + (!(N%dimBlock.x)?0:1) );
	
	int blockSize2d, gridSize2d;
	blockSize2d = 4;
	gridSize2d = (Size/blockSize2d) + (!(Size%blockSize2d?0:1)); 
	
	dim3 dimBlockXY(blockSize2d,blockSize2d);
	dim3 dimGridXY(gridSize2d,gridSize2d);

    // begin timing kernels
	cudaDeviceSynchronize();
	float l_fTime;
        //Creating event to find the elapsed time in the GPU while performing the event
        cudaEvent_t l_cStart, l_cStop;
        cudaEventCreate(&l_cStart);
        cudaEventCreate(&l_cStop);
        cudaEventRecord(l_cStart, 0);
	for (t=0; t<(Size-1); t++) {
		Fan1<<<dimGrid,dimBlock>>>(m_cuda,a_cuda,Size,t);
		cudaThreadSynchronize();
		Fan2<<<dimGridXY,dimBlockXY>>>(m_cuda,a_cuda,b_cuda,Size,Size-t,t);
		cudaThreadSynchronize();
	}
	// end timing kernels
	cudaEventRecord(l_cStop, 0);
        cudaEventSynchronize(l_cStop);
        cudaEventElapsedTime(&l_fTime, l_cStart, l_cStop);
        printf("Guassion GPU time:  %f ms \n", l_fTime/1000);	
	// copy memory back to CPU
	
	cudaMemcpy(m, m_cuda, Size * Size * sizeof(float),cudaMemcpyDeviceToHost );
	cudaMemcpy(a, a_cuda, Size * Size * sizeof(float),cudaMemcpyDeviceToHost );
	cudaMemcpy(b, b_cuda, Size * sizeof(float),cudaMemcpyDeviceToHost );
	cudaFree(m_cuda);
	cudaFree(a_cuda);
	cudaFree(b_cuda);
}


int checkInputLimits(int pr_iSizeParameter){
        return ( MIN_SIZE <= pr_iSizeParameter && pr_iSizeParameter <= MAX_SIZE) ;
}//checkInputLimits ends

///////////////////////////// GUASSIAN ELIMINATION /////////////////////////////////////////////

/*
   th_uiColumns;
   th_uiRows;
   th_iSizeParameter;
   th_fGuassionElements
 */
void performGaussElimination(int pr_iSizeParameter)
{




        //printf("The input matrix a is:\n");
        //PrintMat(a, Size, Size);
        b = (float *) malloc(Size * sizeof(float));

        InitAry(b, Size);
        //printf("The input array b is:\n");

    performForwardSub();
}    

int main(int argc, char *argv[])
{
   
 int l_iSizeParameter = -1 ;
        if( argc == 2 ){
                l_iSizeParameter = atoi(argv[1]);

                if( checkInputLimits( l_iSizeParameter )){
                        // Defination of multi dimensional array 
                        performGaussElimination( l_iSizeParameter );
                        printf("\n sucess ");
                }
                else{

                        printf("\n Matrix size range should be 64 - 4096 ");
                        exit(-1);
                }
        }//argc if ends
        else{
                if (TEST_DATA)
                        performGaussElimination( TEST_ELEMENT );
                else
                {
                        printf("\n Need Matrix size (Two argument expected i.e size & dataType)!");
                        exit(-1);
                }
        }
        return -1;	

 
    if ( TEST_DATA ) {
        printf("Matrix m is: \n");
        PrintMat(m, Size, Size);

        printf("Matrix a is: \n");
        PrintMat(a, Size, Size);

    }
    
    /*printf("%d,%d\n",size,time_total);
    fprintf(stderr,"%d,%d\n",size,time_total);*/
    
    free(m);
    free(a);
    free(b);
}
