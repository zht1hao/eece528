#include <stdlib.h>
#include <stdio.h>
#include <sys/time.h>
#include <string.h>
#include <math.h>

#ifndef ARG_SIZE
#define BLOCK_SIZE 64
#else
#define BLOCK_SIZE ARG_SIZE
#endif

// includes, kernels
//#include "gauss_eliminate_kernel.cu"
#ifndef ARG_MATRIX_SIZE
#define MATRIX_SIZE 4096
#else
#define MATRIX_SIZE ARG_MATRIX_SIZE
#endif

// Matrix dimensions
#define NUM_COLUMNS MATRIX_SIZE // Number of columns in Matrix A
#define NUM_ROWS MATRIX_SIZE // Number of rows in Matrix A

// Matrix Structure declaration
typedef struct {
	//width of the matrix represented
    unsigned int num_columns;
	//height of the matrix represented
    unsigned int num_rows;
	//number of elements between the beginnings of adjacent
	// rows in the memory layout (useful for representing sub-matrices)
    unsigned int pitch;
	//Pointer to the first element of the matrix represented
    float* elements;
} Matrix;
#define MIN_NUMBER 2
#define MAX_NUMBER 50

extern "C" int compute_gold(float*, const float*, unsigned int);
Matrix allocate_matrix_on_gpu(const Matrix M);
Matrix allocate_matrix(int num_rows, int num_columns, int init);
void copy_matrix_to_device(Matrix Mdevice, const Matrix Mhost);
void copy_matrix_from_device(Matrix Mhost, const Matrix Mdevice);
void gauss_eliminate_on_device(const Matrix M, Matrix P);
void subtract(float *, float *, int);
int perform_simple_check(const Matrix M);
void print_matrix(const Matrix M);
void write_matrix_to_file(const Matrix M);
float get_random_number(int, int);
void checkCUDAError(const char *msg);
int checkResults(float *reference, float *gpu_result, int num_elements, float threshold);
__global__ void gauss_eliminate_kernel_reduce(float *U, int i, int N)
{
    unsigned int col = (blockIdx.y * (blockDim.x * blockDim.y)) + ((threadIdx.y * blockDim.x) + threadIdx.x) + i + 1;
    unsigned int col_stride = blockDim.x * blockDim.y * gridDim.y;
    float E = U[i * N + i];

    unsigned int j;
    for (j = col; j < N; j += col_stride)
    {
        U[i * N + j] /= E;
    }
}

__global__ void gauss_eliminate_kernel_eliminate(float *U, int N, int it)
{
    unsigned int row = blockIdx.y * blockDim.y + threadIdx.y + it + 1;
    unsigned int row_stride = blockDim.y * gridDim.y;
    unsigned int col = blockIdx.x * blockDim.x + threadIdx.x;
    unsigned int col_stride = blockDim.x * gridDim.x;

    __shared__ float partials[BLOCK_SIZE][BLOCK_SIZE];

    U[it * N + it] = 1;

    unsigned int i, j;
    float temp;
    for (i = row; i < N; i += row_stride)
    {
        // Multiply by the principal element in each row
        temp = U[i * N + it];
        __syncthreads();

        for (j = col; j < N; j += col_stride)
        {
            // Fill partials matrix with the element in the reducing row for the given column
            partials[threadIdx.x][threadIdx.y] = U[it * N + j];

            // Subtract the product from the current element
            U[i * N + j] -= __fmul_rn(temp, partials[threadIdx.x][threadIdx.y]);
        }
    }
}

int 
compute_gold(float* U, const float* A, unsigned int num_elements){
	unsigned int i, j, k;
	
	// Copy the contents of the A matrix into the U matrix
    for (i = 0; i < num_elements; i ++)
		for(j = 0; j < num_elements; j++)
			U[num_elements * i + j] = A[num_elements*i + j];

	// Perform Gaussian elimination in place on the U matrix
	for (k = 0; k < num_elements; k++){
		for (j = (k + 1); j < num_elements; j++){ // Reduce the current row
			if (U[num_elements*k + k] == 0){
				printf("Numerical instability detected. The principal diagonal element is zero. \n");
				return 0;
			}
            U[num_elements * k + j] = (float)(U[num_elements * k + j] / U[num_elements * k + k]); // Division step
		}
		
        U[num_elements * k + k] = 1; // Set the principal diagonal entry in U to be 1 
        for (i = (k+1); i < num_elements; i++){
			for (j = (k+1); j < num_elements; j++)
				U[num_elements * i + j] = U[num_elements * i + j] - (U[num_elements * i + k] * U[num_elements * k + j]); // Elimination step
			
			U[num_elements * i + k] = 0; 
		} 
	}	
	return 1;
}

int 
main(int argc, char** argv) 
{
    // Matrices for the program
	Matrix  A; // The NxN input matrix
	Matrix  U; // The upper triangular matrix 
	
	// Initialize the random number generator with a seed value 
	srand(time(NULL));
	
	// Check command line arguments
	if(argc > 1){
		printf("Error. This program accepts no arguments. \n");
		exit(0);
	}		
	 
	// Allocate and initialize the matrices
	A  = allocate_matrix(MATRIX_SIZE, MATRIX_SIZE, 1);
	U  = allocate_matrix(MATRIX_SIZE, MATRIX_SIZE, 0); 

	// Perform Gaussian elimination on the CPU 
	Matrix reference = allocate_matrix(MATRIX_SIZE, MATRIX_SIZE, 0);

    struct timeval start, stop;
    gettimeofday(&start, NULL);

	
	gettimeofday(&stop, NULL);
    printf("Execution time = %fs. \n", (float)(stop.tv_sec - start.tv_sec +
            (stop.tv_usec - start.tv_usec)/(float)1000000));

        //print_matrix(reference);

	int status =  compute_gold(reference.elements, A.elements, A.num_rows);


	if(status == 0){
		printf("Failed to convert given matrix to upper triangular. Try again. Exiting. \n");
		exit(0);
	}
	status = perform_simple_check(reference); // Check that the principal diagonal elements are 1 
	if(status == 0){
		printf("The upper triangular matrix is incorrect. Exiting. \n");
		exit(0); 
	}
	printf("Gaussian elimination on the CPU was successful. \n");

	// Perform the vector-matrix multiplication on the GPU. Return the result in U
	gauss_eliminate_on_device(A, U);

	//print_matrix(U);

	int num_elements = MATRIX_SIZE*MATRIX_SIZE;
    int res = checkResults(reference.elements, U.elements, num_elements, 0.001f);
    printf("Test %s\n", (1 == res) ? "PASSED" : "FAILED");

        //subtract(reference.elements, U.elements, num_elements);
        //print_matrix(U);

	// Free host matrices
	free(A.elements); A.elements = NULL;
	free(U.elements); U.elements = NULL;
	free(reference.elements); reference.elements = NULL;

	return 0;
}


void 
gauss_eliminate_on_device(const Matrix A, Matrix U)
{
    Matrix A_dev = allocate_matrix_on_gpu(A);
    cudaMemset(A_dev.elements, 0, A_dev.num_rows * A_dev.num_columns * sizeof(float));
    copy_matrix_to_device(A_dev, A);


    int x_dim = BLOCK_SIZE;
    int y_dim = BLOCK_SIZE;
    int z_dim = 1;
    int num_rows = ceil((float)A_dev.num_rows / x_dim) / 8;

    dim3 thread_block(x_dim, y_dim, z_dim);
    dim3 grid(1, num_rows);

    printf("Performing gaussian elimination on the GPU\n");

    struct timeval start, stop;
    gettimeofday(&start, NULL);


    cudaThreadSynchronize();

    int i;
    for (i = 0; i < A_dev.num_rows - 1; ++i)
    {
        // reduce the row
        gauss_eliminate_kernel_reduce <<< grid, thread_block >>> (A_dev.elements, i, A_dev.num_columns);

        cudaThreadSynchronize();


        //if (i == 1) break;

        // Perform joint reduction/elimination iteratively upon grid
        gauss_eliminate_kernel_eliminate <<< grid, thread_block >>> (A_dev.elements, A_dev.num_columns, i);

        cudaThreadSynchronize();

    }
    gettimeofday(&stop, NULL);
    printf("Execution time = %fs. \n", (float)(stop.tv_sec - start.tv_sec +
            (stop.tv_usec - start.tv_usec)/(float)1000000));

    copy_matrix_from_device(U, A_dev);
    U.elements[(U.num_rows * U.num_columns) - 1] = 1;

    cudaFree(A_dev.elements);
}

// Allocate a device matrix of same size as M.
Matrix 
allocate_matrix_on_gpu(const Matrix M){
    Matrix Mdevice = M;
    int size = M.num_rows * M.num_columns * sizeof(float);
    cudaMalloc((void**)&Mdevice.elements, size);
    return Mdevice;
}

// Allocate a matrix of dimensions height*width
//	If init == 0, initialize to all zeroes.  
//	If init == 1, perform random initialization.
Matrix 
allocate_matrix(int num_rows, int num_columns, int init){
    	Matrix M;
    	M.num_columns = M.pitch = num_columns;
    	M.num_rows = num_rows;
    	int size = M.num_rows * M.num_columns;
		
	M.elements = (float*) malloc(size*sizeof(float));
	for(unsigned int i = 0; i < size; i++){
		if(init == 0) M.elements[i] = 0; 
		else
            M.elements[i] = get_random_number(MIN_NUMBER, MAX_NUMBER);
	}
    return M;
}	

// Copy a host matrix to a device matrix.
void 
copy_matrix_to_device(Matrix Mdevice, const Matrix Mhost)
{
    int size = Mhost.num_rows * Mhost.num_columns * sizeof(float);
    Mdevice.num_rows = Mhost.num_rows;
    Mdevice.num_columns = Mhost.num_columns;
    Mdevice.pitch = Mhost.pitch;
    cudaMemcpy(Mdevice.elements, Mhost.elements, size, cudaMemcpyHostToDevice);
}

// Copy a device matrix to a host matrix.
void 
copy_matrix_from_device(Matrix Mhost, const Matrix Mdevice){
    int size = Mdevice.num_rows * Mdevice.num_columns * sizeof(float);
    cudaMemcpy(Mhost.elements, Mdevice.elements, size, cudaMemcpyDeviceToHost);
}

// Prints the matrix out to screen
void 
print_matrix(const Matrix M){
	for(unsigned int i = 0; i < M.num_rows; i++){
		for(unsigned int j = 0; j < M.num_columns; j++)
			printf("%f ", M.elements[i*M.num_rows + j]);
		printf("\n");
	} 
	printf("\n");
}

// Returns a random floating-point number between the specified min and max values 
float 
get_random_number(int min, int max){
	return (float)floor((double)(min + (max - min + 1)*((float)rand()/(float)RAND_MAX)));
}

// Performs a simple check on the upper triangular matrix. Checks to see if the principal diagonal elements are 1
int 
perform_simple_check(const Matrix M){
	for(unsigned int i = 0; i < M.num_rows; i++)
        if((fabs(M.elements[M.num_rows*i + i] - 1.0)) > 0.001) return 0;
	
    return 1;
} 

// Writes the matrix to a file 
void 
write_matrix_to_file(const Matrix M){
	FILE *fp;
	fp = fopen("matrix.txt", "wt");
	for(unsigned int i = 0; i < M.num_rows; i++){
        for(unsigned int j = 0; j < M.num_columns; j++)
            fprintf(fp, "%f", M.elements[i*M.num_rows + j]);
        }
    fclose(fp);
}

void 
checkCUDAError(const char *msg)
{
	cudaError_t err = cudaGetLastError();
	if( cudaSuccess != err) 
	{
		printf("CUDA ERROR: %s (%s).\n", msg, cudaGetErrorString(err));
		exit(EXIT_FAILURE);
	}						 
}

void subtract(float *reference, float *gpu_result, int num_elements)
{
    for(int i = 0; i < num_elements; i++)
        gpu_result[i] = fabsf((reference[i] - gpu_result[i]));
}

int 
checkResults(float *reference, float *gpu_result, int num_elements, float threshold)
{
    int checkMark = 1;
    float epsilon = 0.0;
    
    for(int i = 0; i < num_elements; i++)
        if(fabsf((reference[i] - gpu_result[i])/reference[i]) > threshold){
            checkMark = 0;
            break;
        }

    for(int i = 0; i < num_elements; i++)
        if(fabsf((reference[i] - gpu_result[i])/reference[i]) > epsilon){
            epsilon = fabsf((reference[i] - gpu_result[i])/reference[i]);
        }

    printf("Max epsilon = %f. \n", epsilon); 
    return checkMark;
}
